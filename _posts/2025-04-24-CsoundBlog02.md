---
title: "Script per il calcolo della RAM allocata in fase di inizializzazione su csound"
excerpt: "Csound occhio! --> 2025-04-20"
classes: wide
categories:
  - Diary
tags:
  - Csound_tricks
---

# Documentazione: Calcolo della RAM in inizializzazione Csound

Questo documento descrive come viene calcolata la memoria occupata da:

- **Variabili globali** (prefissi `gi_`, `gk_`, `ga_`, `gp_`‚Ä¶)  
- **Tabelle globali** generate con `ftgen`  

e come utilizzare lo script Python `calc_mem.py` per ottenere un report dettagliato.

---

## 1. Concetti chiave

1. **MYFLT**  
   - Tipo utilizzato da Csound per variabili e valori di table.  
   - Di default a doppia precisione (64‚ÄØbit ‚Üí **8‚ÄØbyte** per valore).

2. **Variabili globali**  
   - Definite nel `.orc` con `init` o `=`.  
   - Ogni variabile occupa **8‚ÄØbyte**.

3. **Tabelle ftgen**  
   - Un array di `N` punti + **1 guard point** per l‚Äôinterpolazione.  
   - Memoria = (N + 1) √ó 8‚ÄØbyte.

4. **Macro `$NOME`**  
   - Sostituite automaticamente dallo script in `gi_NOME` per un parsing corretto.

---

## 2. Funzionamento dello script

1. **Parsing**  
   - Legge tutte le righe del file `.orc`.  
   - Raccoglie definizioni di variabili globali (`init`, `=`).  
   - Sostituisce macro `$NOME` ‚Üí `gi_NOME`.  

2. **Risoluzione variabili**  
   - Memorizza ogni espressione in `var_exprs`.  
   - Risolve iterativamente con `eval`, finch√© riesce.

3. **Estrazione ftgen**  
   - Individua ogni riga con `ftgen`.  
   - Valuta l‚Äôespressione di dimensione (anche se √® `gi_memory_duration / gi_memory_resolution` o `gi_state_history_size * 11`).  
   - Calcola `base_points = int(size_val)`, `total_points = base_points + 1`, `mem_bytes = total_points √ó 8`.

4. **Report e CSV**  
   - Stampa su console i dettagli.  
   - Esporta in **CSV** (`memory_report.csv` o nome a piacere) con:
   ```csv
   Type,Name,Line/Count,Expr/BasePoints,TotalPoints,MemBytes
   var,gi_Index,,,,8
   ...
   table,gi_eve_attacco,27,gi_NUMEVENTI/1000,1001,8008
   ...
   summary,,,,"MemVarsBytes",4096
   summary,,,,"MemTablesBytes",123456
   summary,,,,"TotalMemBytes",127552
    ```
---
## 3. Esempio di esecuzione

```bash
python calc_mem.py MACROS/init.orc memoria.csv
```

  - Output console:
    ```yaml
    üìÑ File: MACROS/init.orc
    üî¢ Variabili globali risolte:  fifty ‚Üí 400 byte
    üìä Tabelle ftgen trovate:
    riga 27: gi_eve_attacco size=gi_NUMEVENTI ‚Üí1000+1 ‚Üí1001 punti, mem=8008 byte
    ...
    üß† Memoria tabelle: 123456 byte
    üßÆ Memoria totale stimata: 127552 byte (124.75 kB)
    ‚úÖ Dettagli esportati in memoria.csv
    ```
  - Contenuto di memoria.csv:
    Vedi sezione 2.
---
## 4. Come interpretare i risultati

  - MemVarsBytes: memoria totale occupata dalle variabili globali.
  - MemTablesBytes: memoria totale occupata dalle tabelle ftgen.
  - TotalMemBytes: somma delle due, stimata all‚Äôinit-time di Csound.

## 5. Appendice
Script di python
```python
import re
import sys
import csv

def parse_orc_memory(filepath, bytes_per_value=8, csv_path="memory_report.csv"):
    # Regex per variabili e tabelle
    init_re   = re.compile(r'^\s*(g[akip]\w*)\s+init\s+(.+)$')
    assign_re = re.compile(r'^\s*(g[akip]\w*)\s*=\s*(.+)$')
    ftgen_re  = re.compile(r'^\s*(g[akip]\w*)\s+ftgen\s+[^,]+,\s*[^,]+,\s*([^,]+)')

    var_exprs  = {}
    var_values = {}

    # 1) Leggi e sostituisci macro $NOME ‚Üí gi_NOME
    lines = []
    with open(filepath) as f:
        for line in f:
            line = re.sub(r'\$(\w+)', r'gi_\1', line)
            lines.append(line)
            m = init_re.match(line) or assign_re.match(line)
            if m:
                name, expr = m.groups()
                var_exprs[name.strip()] = expr.strip()

    # 2) Risolvi iterativamente le espressioni
    changed = True
    while changed:
        changed = False
        for name, expr in list(var_exprs.items()):
            if name in var_values:
                continue
            try:
                val = eval(expr, {}, var_values)
                var_values[name] = float(val)
                changed = True
            except Exception:
                continue

    # 3) Calcola tabelle ftgen
    tables = []
    for lineno, line in enumerate(lines, 1):
        m = ftgen_re.match(line)
        if not m: continue
        name, size_expr = m.groups()
        try:
            size_val = eval(size_expr, {}, var_values)
        except Exception:
            print(f"‚ö†Ô∏è Warning: non ho potuto valutare ‚Äú{size_expr}‚Äù a riga {lineno}")
            continue
        base_size = int(abs(size_val))
        points    = base_size + 1
        mem       = points * bytes_per_value
        tables.append({
            "line": lineno,
            "name": name,
            "expr": size_expr,
            "base_points": base_size,
            "total_points": points,
            "mem_bytes": mem
        })

    # 4) Memoria variabili semplici
    simple_vars = sorted(var_values.keys())
    mem_simple  = len(simple_vars) * bytes_per_value
    mem_tables  = sum(t["mem_bytes"] for t in tables)
    total_mem   = mem_simple + mem_tables

    # --- Stampa su console ---
    print(f"üìÑ File: {filepath}")
    print(f"üî¢ Variabili globali risolte: {len(simple_vars)} ‚Üí {mem_simple} byte")
    print("üìä Tabelle ftgen trovate:")
    for t in tables:
        print(f"  riga {t['line']}: {t['name']} size={t['expr']} ‚Üí"
              f" {t['base_points']}+1 ‚Üí {t['total_points']} punti, mem={t['mem_bytes']} byte")
    print(f"üß† Memoria tabelle: {mem_tables} byte")
    print(f"üßÆ Memoria totale stimata: {total_mem} byte ({total_mem/1024:.2f} kB)")

    # --- Esporta in CSV ---
    with open(csv_path, "w", newline="") as csvfile:
        writer = csv.writer(csvfile)
        # Header
        writer.writerow(["Type","Name","Line/Count","Expr/BasePoints","TotalPoints","MemBytes"])
        # Variabili
        for name in simple_vars:
            writer.writerow(["var", name, "", "", "", bytes_per_value])
        # Tabelle
        for t in tables:
            writer.writerow([
                "table", t["name"], t["line"],
                f"{t['expr']}/{t['base_points']}",
                t["total_points"], t["mem_bytes"]
            ])
        # Totali
        writer.writerow([])
        writer.writerow(["summary","", "", "", "MemVarsBytes", mem_simple])
        writer.writerow(["summary","", "", "", "MemTablesBytes", mem_tables])
        writer.writerow(["summary","", "", "", "TotalMemBytes", total_mem])
    print(f"\n‚úÖ Dettagli esportati in {csv_path}")

if __name__ == "__main__":
    if len(sys.argv) not in (2,3):
        print("Uso: python calc_mem.py init.orc [output.csv]")
        sys.exit(1)
    csv_out = sys.argv[2] if len(sys.argv)==3 else "memory_report.csv"
    parse_orc_memory(sys.argv[1], csv_path=csv_out)

    # python calc_mem.py MACROS/init.orc memoria.csv
```

